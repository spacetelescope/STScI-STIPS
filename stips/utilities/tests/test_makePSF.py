from astropy.io import fits
from scipy import ndimage
from stips.utilities import makePSF
from stips.utilities.utilities import StipsEnvironment
import numpy as np
import os
import pytest
stips_version = StipsEnvironment.__stips__version__

# Basic carryover constants from the original makePSF file
# This will save time in later calculations

IPC = np.array([[0.21, 1.62, 0.2],
                [1.88, 91.59, 1.87],
                [0.21, 1.66, 0.22]]) / 100.0

EPSF4 = np.array([[0.25, 0.5, 0.5, 0.5, 0.25],
                  [0.5, 1., 1., 1., 0.5],
                  [0.5, 1., 1., 1., 0.5],
                  [0.5, 1., 1., 1., 0.5],
                  [0.25, 0.5, 0.5, 0.5, 0.25]])

PSF_UPSCALE = 4

PSF_BOXSIZE = 44
PSF_BRIGHT_BOXSIZE = 88
PSF_EXTRA_BRIGHT_BOXSIZE = 176

PSF_GRID_SIZE = 3


# Rounding (just a modification to stop potential future issues)
def rind(x):
    return np.round(x).astype(int)


# Import the .fits PSF file, which will be the test PSF against which we can run all
# comparative tests and select the part of the data we'll use to construct the test PSF
file_dir = os.path.dirname(os.path.abspath(__file__))
data_dir = os.path.join(file_dir, "..", "..", "data", "psf_WFI_2.0.0_F129_wfi01.fits")
file = fits.open(data_dir)

file_in = file[0].data[0]

# Generate the test PSF using the make_epsf function from makePSF
# We can now use this basic PSF as a comparative standard against which to check the makePSF code

test_psf = makePSF.make_epsf(file[0].data[0])

# Set a few basic variables for use in testing the bicubic function of makePSF

ix = 1
iy = 2
fx = 0.25
fy = 0.75

# Generate both a bicubic interpolation (to see fractional light output) from the bicubic function,
# and a fractional light output from the real_psf function
# These will both be used in later tests –– it's more efficent to generate them here

test_phot = makePSF.bicubic(test_psf, iy, ix, fx, fy)

test_rpsf_phot = makePSF.real_psf(10, 15, test_psf,
                                  psf_center=88, boxsize=PSF_EXTRA_BRIGHT_BOXSIZE)


def test_make_epsf_calcs():

    # Running the individual steps of make_epsf, starting with setting the shape of the array.
    # Empty the array to fill later
    psf_test_mid = np.zeros_like(file_in)

    # Assuming the PSF is square
    size_test = file_in.shape[0]

    # Convolve the input file with the EPSF4 array
    psf_test_mid = ndimage.convolve(file_in, EPSF4, mode='constant', cval=0.0)

    # Rather than indvidually checking each calculation against the value generated by make_epsf,
    # we nstead run a check on a randomly selected set of the values generated.
    # This way, we can test a sample set of the calculations,
    # without overburdening the test by checking all of them.

    # First, apply the correct scaling to the rows and columns

    psf_test_mid[0:size_test, 0] = file_in[0:size_test, 0]*16.0

    psf_test_mid[0:size_test, size_test - 2] = file_in[0:size_test, size_test - 2] * 16.

    psf_test_mid[1, 3:(size_test - PSF_UPSCALE) + 1] = \
        file_in[1, 3:(size_test - PSF_UPSCALE) + 1] * 16.0

    psf_test_mid[size_test - 2, 3:(size_test - PSF_UPSCALE) + 1] = \
        file_in[size_test - 2, 3:(size_test - PSF_UPSCALE) + 1] * 16.0

    # Empty the array

    psf_test_out = np.zeros_like(file_in)

    # Run the final calculations for the pixels in the PSF image

    x_range = range(PSF_UPSCALE, size_test-PSF_UPSCALE-1)
    y_range = range(PSF_UPSCALE, size_test-PSF_UPSCALE-1)

    # Add the IPC to the output PSF

    for idx in x_range:
        for idy in y_range:
            pcen = psf_test_mid[idy, idx]

            psf_test_out[idy-PSF_UPSCALE, idx-PSF_UPSCALE] += pcen*IPC[0, 0]
            psf_test_out[idy-PSF_UPSCALE, idx] += pcen*IPC[0, 1]
            psf_test_out[idy-PSF_UPSCALE, idx+PSF_UPSCALE] += pcen*IPC[0, 2]

            psf_test_out[idy, idx-PSF_UPSCALE] += pcen*IPC[1, 0]
            psf_test_out[idy, idx] += pcen*IPC[1, 1]
            psf_test_out[idy, idx+PSF_UPSCALE] += pcen*IPC[1, 2]

            psf_test_out[idy+PSF_UPSCALE, idx-PSF_UPSCALE] += pcen*IPC[2, 0]
            psf_test_out[idy+PSF_UPSCALE, idx] += pcen*IPC[2, 1]
            psf_test_out[idy+PSF_UPSCALE, idx+PSF_UPSCALE] += pcen*IPC[2, 2]

    # Check the generated values at the selected points against the values in the test psf,
    # generate previously via make_epsf.

    np.testing.assert_allclose(test_psf[0:size_test, 0], psf_test_out[0:size_test, 0])

    np.testing.assert_allclose(test_psf[0:size_test, size_test-2],
                               psf_test_out[0:size_test, size_test-2])

    np.testing.assert_allclose(test_psf[1, 3:(size_test-PSF_UPSCALE)+1],
                               psf_test_out[1, 3:(size_test-PSF_UPSCALE)+1])

    np.testing.assert_allclose(test_psf[size_test-2, 3:(size_test-PSF_UPSCALE)+1],
                               psf_test_out[size_test-2, 3:(size_test-PSF_UPSCALE)+1])


def test_bicubic():

    # Run the calculations of the bicubic function "manually".

    A1 = test_psf[2, 1]
    B1 = (test_psf[2, 2]-test_psf[2, 0])/2
    C1 = (test_psf[3, 1]-test_psf[1, 1])/2
    D1 = (test_psf[2, 2]+test_psf[2, 0]-2*A1)/2
    E1 = (test_psf[3, 2]-A1)
    F1 = (test_psf[3, 1]+test_psf[1, 1]-2*A1)/2
    V1 = (A1
          + B1*(fx)
          + C1*(fy)
          + D1*(fx)**2
          + E1*(fx)*(fy)
          + F1*(fy)**2)

    # Lower Right Value
    A2 = test_psf[2, 2]
    B2 = (test_psf[2, 3]-test_psf[2, 1])/2
    C2 = (test_psf[3, 2]-test_psf[1, 2])/2
    D2 = (test_psf[2, 3]+test_psf[2, 1]-2*A2)/2
    E2 = -(test_psf[3, 1]-A2)
    F2 = (test_psf[3, 2]+test_psf[1, 2]-2*A2)/2
    V2 = (A2
          + B2*(fx-1)
          + C2*(fy)
          + D2*(fx-1)**2
          + E2*(fx-1)*(fy)
          + F2*(fy)**2)

    # Upper Left Value
    A3 = test_psf[3, 1]
    B3 = (test_psf[3, 2]-test_psf[3, 0])/2
    C3 = (test_psf[4, 1]-test_psf[2, 1])/2
    D3 = (test_psf[3, 2]+test_psf[3, 0]-2*A3)/2
    E3 = -(test_psf[2, 2]-A3)
    F3 = (test_psf[4, 1]+test_psf[2, 1]-2*A3)/2
    V3 = (A3
          + B3*(fx)
          + C3*(fy-1)
          + D3*(fx)**2
          + E3*(fx)*(fy-1)
          + F3*(fy-1)**2)

    # Upper Right Value
    A4 = test_psf[3, 2]
    B4 = (test_psf[3, 3]-test_psf[3, 1])/2
    C4 = (test_psf[4, 2]-test_psf[2, 2])/2
    D4 = (test_psf[3, 3]+test_psf[3, 1]-2*A4)/2
    E4 = (test_psf[2, 1]-A4)
    F4 = (test_psf[4, 2]+test_psf[2, 2]-2*A4)/2
    V4 = (A4
          + B4*(fx-1)
          + C4*(fy-1)
          + D4*(fx-1)**2
          + E4*(fx-1)*(fy-1)
          + F4*(fy-1)**2)

    check_phot = ((1-fx)*(1-fy)*V1
                  + (fx)*(1-fy)*V2
                  + (1-fx)*(fy)*V3
                  + (fx)*(fy)*V4)

    # Check this calculated value against the value generated previously by the bicubic function.

    np.testing.assert_allclose(test_phot, check_phot)


def test_real_psf():

    # "Manually" run the calculations for the real_psf function, using some preset
    # variables to check against these same variables (dx = 10 and dy = 15) were used
    # to generate the test value from real_psf previously.

    dx = 10
    dy = 15

    rx = 88 + 10*4
    ry = 88 + 15*4
    ix_rpsf = int(rx)
    iy_rpsf = int(ry)
    fx_rpsf = rx-ix_rpsf  # Pixel Phase
    fy_rpsf = ry-iy_rpsf  # Pixel Phase
    dd = np.sqrt(dx**2+dy**2)

    check_rpsf_phot = ((1-fx_rpsf)*(1-fy_rpsf)*test_psf[iy_rpsf, ix_rpsf]
                       + (fx_rpsf)*(1-fy_rpsf)*test_psf[iy_rpsf, ix_rpsf+1]
                       + (1-fx_rpsf)*(fy_rpsf)*test_psf[iy_rpsf+1, ix_rpsf]
                       + (fx_rpsf)*(fy_rpsf)*test_psf[iy_rpsf+1, ix_rpsf+1])

    # Check the "manually" calculated value against the value generated by real_psf.

    np.testing.assert_allclose(test_rpsf_phot, check_rpsf_phot)


def test_place_source():

    # Place a test source in a blank image, to ensure that this doesn't throw any exceptions.
    # Just a check to make sure the function runs with no issues.

    image = np.zeros(shape=[512, 512, 3], dtype=np.float64)

    psf_middle = rind((test_psf[0].shape[0]-1)/2)

    PSF_BOXSIZE = np.floor(psf_middle)/PSF_UPSCALE

    test_placement = makePSF.place_source(250, 250, 15, image, test_psf,
                                          boxsize=PSF_BOXSIZE, psf_center=psf_middle)


def test_interpolate():

    # This test is designed to test interpolations of input ePSFs in each quadrant
    # to ensure the calculations for each quadrant run correctly.

    # Get image size read in from test_psf

    image_size = file_in.shape[0]

    half_image = round(image_size/2)

    # Generate a psf_array –– for simplicity, we set the array as test_psf three times

    test_psf_array = [test_psf, test_psf, test_psf]

    # Lower Left Quadrant

    # Set location to the lower left quadrant

    xpix_ll = 68
    ypix_ll = 68

    # Run interpolate_epsf using the test psf array, the set image size, and the
    # specified coordinates for this quadrant.

    interp_epsf_ll = makePSF.interpolate_epsf(xpix_ll, ypix_ll, test_psf_array, image_size)

    # "Manually" run the calculations of the interpolate_epsf function.

    xf_ll = ((xpix_ll + 4) / (half_image + 4))
    yf_ll = ((ypix_ll + 4) / (half_image + 4))
    check_interp_ll = (xf_ll * yf_ll * test_psf_array[1][1] +
                       (1 - xf_ll) * (1 - yf_ll) * test_psf_array[0][0] +
                       (xf_ll) * (1 - yf_ll) * test_psf_array[1][0] +
                       (1 - xf_ll) * (yf_ll) * test_psf_array[0][1])

    # Upper Left Quadrant

    # Set location to upper left quadrant

    xpix_ul = 68
    ypix_ul = 108

    # Run interpolate_epsf using the test psf array, the set image size, and the
    # specified coordinates for this quadrant.

    interp_epsf_ul = makePSF.interpolate_epsf(xpix_ul, ypix_ul, test_psf_array, image_size)

    # "Manually" run the calculations of the interpolate_epsf function.

    xf_ul = ((xpix_ul + 4) / (half_image + 4))
    yf_ul = ((ypix_ul + 4 - (half_image + 4)) / (half_image + 4))
    check_interp_ul = (xf_ul * yf_ul * test_psf_array[1][2] +
                       (1 - xf_ul) * (1 - yf_ul) * test_psf_array[0][1] +
                       (xf_ul) * (1 - yf_ul) * test_psf_array[1][1] +
                       (1 - xf_ul) * (yf_ul) * test_psf_array[0][2])

    # Lower Right Quadrant

    # Set location to lower right quadrant

    xpix_lr = 108
    ypix_lr = 68

    # Run interpolate_epsf using the test psf array, the set image size,
    # and the specified coordinates for this quadrant.

    interp_epsf_lr = makePSF.interpolate_epsf(xpix_lr, ypix_lr, test_psf_array, image_size)

    # "Manually" run the calculations of the interpolate_epsf function.

    xf_lr = ((xpix_lr + 4 - (half_image + 4)) / (half_image + 4))
    yf_lr = ((ypix_lr + 4) / (half_image + 4))
    check_interp_lr = (xf_lr * yf_lr * test_psf_array[2][1] +
                       (1-xf_lr) * (1-yf_lr) * test_psf_array[1][0] +
                       (xf_lr) * (1-yf_lr) * test_psf_array[2][0] +
                       (1-xf_lr) * (yf_lr) * test_psf_array[1][1])

    # Upper Right Quadrant

    # Set location to upper right quadrant.

    xpix_ur = 108
    ypix_ur = 108

    # Run interpolate_epsf using the test psf array, the set image size,
    # and the specified coordinates for this quadrant.

    interp_epsf_ur = makePSF.interpolate_epsf(xpix_ur, ypix_ur, test_psf_array, image_size)

    # "Manually" run the calculations of the interpolate_epsf function.

    xf_ur = ((xpix_ur + 4 - (half_image + 4)) / (half_image + 4))
    yf_ur = ((ypix_ur + 4 - (half_image + 4)) / (half_image + 4))
    check_interp_ur = (xf_ur * yf_ur * test_psf_array[2][2] +
                       (1-xf_ur) * (1-yf_ur) * test_psf_array[1][1] +
                       (xf_ur) * (1-yf_ur) * test_psf_array[2][1] +
                       (1-xf_ur)*(yf_ur)*test_psf_array[1][2])

    # Check that each interpolation in each qudrant generated by
    # interpolate_epsf matches the check value.

    np.testing.assert_allclose(interp_epsf_ll, check_interp_ll, atol=0.001)

    np.testing.assert_allclose(interp_epsf_ul, check_interp_ul, atol=0.001)

    np.testing.assert_allclose(interp_epsf_lr, check_interp_lr, atol=0.001)

    np.testing.assert_allclose(interp_epsf_ur, check_interp_ur, atol=0.001)
